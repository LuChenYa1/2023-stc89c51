C51 COMPILER V9.59.0.0   MATRIXKEY                                                         11/23/2023 18:43:13 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MATRIXKEY
OBJECT MODULE PLACED IN .\Objects\Matrixkey.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE Matrixkey.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\Matrixkey.lst) OBJECT(.\Objects\Matrixkey.obj)

line level    source

   1          //#include <REGX51.H>
   2          //#include <delay.h>
   3          // 
   4          // /**
   5          //  * @brief  矩阵键盘读取按键键码
   6          //  * @param  参数无
   7          //  * @retval 返回值为键码
   8          //      按下并松开后重新赋值并显示
   9          //  */  
  10          //unsigned char MatrixKey()
  11          // {
  12          //       //列扫描
  13          //       unsigned char KeyNum = 0;
  14          //       P1=0xff;
  15          //       P1_0=0;      //确定扫描列数          
  16          //       if(P1_4==0){delay_ms(20);while(P1_4==0);delay_ms(20);KeyNum=16;}
  17          //       if(P1_5==0){delay_ms(20);while(P1_5==0);delay_ms(20);KeyNum=12;}
  18          //       if(P1_6==0){delay_ms(20);while(P1_6==0);delay_ms(20);KeyNum=8;}
  19          //       if(P1_7==0){delay_ms(20);while(P1_7==0);delay_ms(20);KeyNum=4;}
  20          //       
  21          //       
  22          //       P1=0xff;
  23          //       P1_1=0;
  24          //       if(P1_4==0){delay_ms(20);while(P1_4==0);delay_ms(20);KeyNum=15;}
  25          //       if(P1_5==0){delay_ms(20);while(P1_5==0);delay_ms(20);KeyNum=11;}
  26          //       if(P1_6==0){delay_ms(20);while(P1_6==0);delay_ms(20);KeyNum=7;}
  27          //       if(P1_7==0){delay_ms(20);while(P1_7==0);delay_ms(20);KeyNum=3;}
  28          //       
  29          //       P1=0xff;
  30          //       P1_2=0;
  31          //       if(P1_4==0){delay_ms(20);while(P1_4==0);delay_ms(20);KeyNum=14;}
  32          //       if(P1_5==0){delay_ms(20);while(P1_5==0);delay_ms(20);KeyNum=10;}
  33          //       if(P1_6==0){delay_ms(20);while(P1_6==0);delay_ms(20);KeyNum=6;}
  34          //       if(P1_7==0){delay_ms(20);while(P1_7==0);delay_ms(20);KeyNum=2;}
  35          //       
  36          //       P1=0xff;
  37          //       P1_3=0;
  38          //       if(P1_4==0){delay_ms(20);while(P1_4==0);delay_ms(20);KeyNum=13;}
  39          //       if(P1_5==0){delay_ms(20);while(P1_5==0);delay_ms(20);KeyNum=9;}
  40          //       if(P1_6==0){delay_ms(20);while(P1_6==0);delay_ms(20);KeyNum=5;}
  41          //       if(P1_7==0){delay_ms(20);while(P1_7==0);delay_ms(20);KeyNum=1;}
  42          //       
  43          //       
  44          //       return KeyNum;
  45          // }
  46          
  47          
  48           #include <REGX51.H>
  49           #include <delay.h>
  50           
  51           //定时器扫描矩阵键盘
  52           unsigned char Scan_MatrixKeyNum;
  53           /**
  54            * @brief  矩阵键盘读取按键键码
C51 COMPILER V9.59.0.0   MATRIXKEY                                                         11/23/2023 18:43:13 PAGE 2   

  55            * @param  无
  56            * @retval 键码KeyNum
  57                  按下并松开后重新赋值并显示
  58            */  
  59          unsigned char MatrixKey_GetState()
  60           {
  61   1               //列扫描
  62   1               unsigned char MatrixKeyNum = 0;//这一步赋值0很重要，不能省略
  63   1               P1=0xff;     //全部复位
  64   1               P1_0=0;      //确定扫描列数          
  65   1               if(P1_4==0){MatrixKeyNum=16;}
  66   1               if(P1_5==0){MatrixKeyNum=12;}
  67   1               if(P1_6==0){MatrixKeyNum=8;}
  68   1               if(P1_7==0){MatrixKeyNum=4;}
  69   1               
  70   1               
  71   1               P1=0xff;
  72   1               P1_1=0;
  73   1               if(P1_4==0){MatrixKeyNum=15;}
  74   1               if(P1_5==0){MatrixKeyNum=11;}
  75   1               if(P1_6==0){MatrixKeyNum=7;}
  76   1               if(P1_7==0){MatrixKeyNum=3;}
  77   1               
  78   1               P1=0xff;
  79   1               P1_2=0;
  80   1               if(P1_4==0){MatrixKeyNum=14;}
  81   1               if(P1_5==0){MatrixKeyNum=10;}
  82   1               if(P1_6==0){MatrixKeyNum=6;}
  83   1               if(P1_7==0){MatrixKeyNum=2;}
  84   1               
  85   1               P1=0xff;
  86   1               P1_3=0;
  87   1               if(P1_4==0){MatrixKeyNum=13;}
  88   1               if(P1_5==0){MatrixKeyNum=9;}
  89   1               if(P1_6==0){MatrixKeyNum=5;}
  90   1               if(P1_7==0){MatrixKeyNum=1;}
  91   1                
  92   1               return MatrixKeyNum;
  93   1       }
  94          
  95          //unsigned char MatrixKey_GetState()
  96          // {
  97          //       //线翻转法扫描(失败品)
  98          //       unsigned char MatrixKeyNum = 0, line = 0, column = 0;
  99          //       
 100          //       P1=0xF0;
 101          //       if(P1 != 0xF0)
 102          //       {
 103          ////            delay_ms(1);
 104          //              if(P1 != 0xF0)
 105          //              {
 106          //                      if(P1 == 0xE0)
 107          //                      {line = 4;P2_1 = ~P2_1;}
 108          //                      else if(P1 == 0xD0)line = 3;
 109          //                      else if(P1 == 0xB0)line = 2;
 110          //                      else if(P1 == 0x70)line = 1;
 111          //              }
 112          //       }
 113          //       P1 = 0x0F;
 114          //       if(P1 != 0x0F)
 115          //       {
 116          ////            delay_ms(1);
C51 COMPILER V9.59.0.0   MATRIXKEY                                                         11/23/2023 18:43:13 PAGE 3   

 117          //              if(P1 != 0x0F)
 118          //              {
 119          //                      if(P1 == 0x0E){P2_0 = ~P2_0;column = 4;}
 120          //                      else if(P1 == 0x0D)column = 3;
 121          //                      else if(P1 == 0x0B)column = 2;
 122          //                      else if(P1 == 0x07)column = 1;
 123          //              }
 124          //        }
 125          //       if(MatrixKeyNum == 16)P2_5 = ~P2_5;
 126          //       MatrixKeyNum = (line -1) * 4 + column;
 127          //       return MatrixKeyNum;
 128          // }
 129          
 130          
 131          /**
 132            * @brief  中断时执行的函数，功能是检测按键落下并返回相应的值，去除了原来的delay和死循环
 133            * @param  无
 134            * @retval 无
 135            */
 136          void MatrixKey_Loop(void)
 137          {
 138   1              static unsigned char laststate,nowstate;
 139   1              laststate = nowstate;
 140   1              nowstate = MatrixKey_GetState();
 141   1              //更换10位置可以按下即变，不需松手
 142   1              if(laststate==1&&nowstate==0)Scan_MatrixKeyNum = 1;     
 143   1              else if(laststate==2 && nowstate == 0)Scan_MatrixKeyNum = 2;    
 144   1              else if(laststate==3 && nowstate == 0)Scan_MatrixKeyNum = 3;    
 145   1              else if(laststate==4 && nowstate == 0)Scan_MatrixKeyNum = 4;    
 146   1              else if(laststate==5 && nowstate == 0)Scan_MatrixKeyNum = 5;    
 147   1              else if(laststate==6 && nowstate == 0)Scan_MatrixKeyNum = 6;    
 148   1              else if(laststate==7 && nowstate == 0)Scan_MatrixKeyNum = 7;    
 149   1              else if(laststate==8 && nowstate == 0)Scan_MatrixKeyNum = 8;    
 150   1              else if(laststate==9 && nowstate == 0)Scan_MatrixKeyNum = 9;    
 151   1              else if(laststate==10&& nowstate == 0)Scan_MatrixKeyNum = 10;   
 152   1              else if(laststate==11&& nowstate == 0)Scan_MatrixKeyNum = 11;   
 153   1              else if(laststate==12&& nowstate == 0)Scan_MatrixKeyNum = 12;   
 154   1              else if(laststate==13&& nowstate == 0)Scan_MatrixKeyNum = 13;   
 155   1              else if(laststate==14&& nowstate == 0)Scan_MatrixKeyNum = 14;   
 156   1              else if(laststate==15&& nowstate == 0)Scan_MatrixKeyNum = 15;   
 157   1              else if(laststate==16&& nowstate == 0)Scan_MatrixKeyNum = 16;   
 158   1      }
 159          /**
 160            * @brief  返回按键键码
 161            * @param  无
 162            * @retval 键码
 163            */
 164          unsigned char MatrixKey(void)
 165          {
 166   1              unsigned char temp;
 167   1              temp = Scan_MatrixKeyNum;     //返回按键值前对Scan_KeyNum清零,防止不按下时返回原值
 168   1              Scan_MatrixKeyNum = 0;
 169   1              return temp;
 170   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    356    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3    ----
C51 COMPILER V9.59.0.0   MATRIXKEY                                                         11/23/2023 18:43:13 PAGE 4   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
