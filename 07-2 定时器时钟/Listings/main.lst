C51 COMPILER V9.59.0.0   MAIN                                                              01/08/2025 21:30:01 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          //#include <REGX51.H>
   2          //#include <LCD1602.h>
   3          //#include <Timer0_Init.h>
   4          
   5          //unsigned char sec=52,min=59,hour=23;  //Ê±·ÖÃë
   6          //void main()
   7          //{
   8          //      Timer0_Init();           //Æô¶¯º¯Êý
   9          //      LCD_Init();
  10          //      while(1)
  11          //      {
  12          //              LCD_ShowString(1,1,"Clock:");
  13          //              LCD_ShowNum(2,1,hour,2);
  14          //              LCD_ShowChar(2,3,':');
  15          //              LCD_ShowNum(2,4,min,2);
  16          //              LCD_ShowChar(2,6,':');
  17          //              LCD_ShowNum(2,7,sec,2);
  18          //      }
  19          //      
  20          //}
  21          
  22          //void Timer0_Routine () interrupt 1   //ÖÐ¶ÏÖ´ÐÐº¯ÊýÊ±¼äÒªÇó½Ï¶Ì£¬²»ÄÜÌ«³¤
  23          //{
  24          //      static unsigned int T0count;     //¾²Ì¬¾Ö²¿±äÁ¿£¬±£Ö¤²»»á±»ÖØÐÂ¸³Öµ
  25          
  26          //      TL0 = 0x66;                                      //È·±£ÖÐ¶ÏÊ±¼ä²»±ä
  27          //      TH0 = 0xFC;     
  28          //      T0count++;
  29          //      
  30          //      if(T0count == 1000)              //Ã¿¸ô1000ºÁÃë£¬µÆÁÁÃð±ä»¯
  31          //      {
  32          //              T0count=0;                   
  33          //              sec++;
  34          //              if(sec==60)                  //Óö60½øÒ»
  35          //              {
  36          //                      sec=0;
  37          //                      min++;
  38          //                      if(min==60)
  39          //                      {
  40          //                              min=0;
  41          //                              hour++;
  42          //                              if(hour==24)
  43          //                              {
  44          //                                      hour=0;
  45          //                              }
  46          //                      }
  47          //              }               
  48          //      }
  49          //}
  50          
  51          #include <REGX51.H>
  52          #include<intrins.h>
  53          #define uint unsigned int
  54          #define uchar unsigned char
C51 COMPILER V9.59.0.0   MAIN                                                              01/08/2025 21:30:01 PAGE 2   

  55                  
  56          void delay(uchar z);    //å‡½æ•°å£°æ˜Ž
  57          
  58          void Timer0Init();     //å‡½æ•°å£°æ˜Ž
  59          //----------------------------------------------------------------------
  60          sbit RedLED=P1^0;     // å®šä¹‰ç»¿ç¯çš„I/Oå£
  61          
  62          sbit GreenLED=P1^1;   // å®šä¹‰çº¢ç¯çš„I/Oå£ 
  63          
  64          sbit Key=P3^4;       // å®šä¹‰æŒ‰é”®çš„I/Oå£
  65          
  66          typedef enum
  67          {
  68                  Key_Check,
  69                  Key_Press,
  70                  Key_Release,
  71                  Key_Over,
  72          }Key_State;
  73          
  74          Key_State keyState = Key_Check;//ç»™æŒ‰é”®çŠ¶æ€è®¾ç½®åˆå§‹å€¼
  75          
  76          unsigned char keyPressCount = 0; // å®šä¹‰å…¨å±€å˜é‡è®°å½•æŒ‰é”®æŒ‰ä¸‹æ¬¡æ•°
  77          
  78          unsigned int keyPressTime = 20; // å®šä¹‰å…¨å±€å˜é‡è®°å½•æŒ‰é”®æŒ‰ä¸‹æ—¶é—´
  79          
  80          int KeyStartTime;
  81          
  82          void Key_Scan(void);
  83          //----------------------------------------------------------------------
  84          
  85          void main()
  86          {
  87   1          // åˆå§‹çŠ¶æ€ï¼šçº¢ç¯äº®ã€ç»¿ç¯ç­
  88   1          RedLED=0;                 
  89   1              GreenLED=1;               
  90   1          
  91   1          Timer0Init();             // åˆå§‹åŒ–å®šæ—¶å™¨0
  92   1      
  93   1          while(1)    
  94   1              {        
  95   2              if(keyState == Key_Over)      //åªæœ‰æ¾æ‰‹åŽï¼Œå³æŒ‰åŽ‹æ—¶é—´è®°å½•ç»“æŸï¼Œè¯¥æ ‡å¿—ä½æ‰ä¼š
             -ç½®ä¸€ï¼Œå³ä¸ºæ¾æ‰‹æ‰§è¡ŒåŠŸèƒ½ï¼Œå¸¦é•¿æŒ‰æ—¶é—´æ£€æµ‹
  96   2                  {
  97   3                          keyState = Key_Check;     //ä¿è¯ä»¥ä¸‹ç¨‹åºåªåœ¨åˆšæŒ‰ä¸‹æ—¶æ‰§è¡Œä¸€æ¬¡
  98   3                  
  99   3                  keyPressTime = 20;        //æŒ‰åŽ‹æ—¶é—´â€œæ¸…é›¶â€ï¼Œæ–¹ä¾¿ä¸‹æ¬¡æŒ‰åŽ‹æ—¶è®¡æ—¶
 100   3                  }
 101   2      
 102   2              if(keyState == Key_Release)
 103   2              {
 104   3                  if(keyPressTime >= 2000)  // é•¿æŒ‰è¶…è¿‡2ç§’
 105   3                  {   
 106   4                      keyPressCount = 0;
 107   4                      RedLED = 0;           // å¤ä½åˆå€¼ï¼Œçº¢ç¯äº®ï¼Œç»¿ç¯ç­
 108   4                      GreenLED = 1;                           
 109   4                  }
 110   3                  else
 111   3                  {
 112   4                      if(keyPressCount==1)  // æ ¹æ®æŒ‰é”®æŒ‰ä¸‹æ¬¡æ•°æŽ§åˆ¶ç¯çš„äº®ç­                             
 113   4                      {
 114   5                          RedLED = 1;
 115   5                          GreenLED = 0;
C51 COMPILER V9.59.0.0   MAIN                                                              01/08/2025 21:30:01 PAGE 3   

 116   5                      } 
 117   4                      else if(keyPressCount==2)
 118   4                      {
 119   5                          RedLED = 0;
 120   5                          GreenLED = 0;
 121   5                      } 
 122   4                      else if(keyPressCount==3)// æŒ‰é”®ç¬¬ä¸‰æ¬¡æŒ‰ä¸‹
 123   4                      {
 124   5                          RedLED = 0;          // å¤ä½åˆå€¼ï¼Œçº¢ç¯äº®ï¼Œç»¿ç¯ç­
 125   5                          GreenLED = 1;                                                                                                               
 126   5                      }
 127   4                  }
 128   3              }
 129   2              }
 130   1      }
 131          
 132          void Timer0_ISR() interrupt 1    // å®šæ—¶å™¨0ä¸­æ–­æœåŠ¡å‡½æ•°
 133          { 
 134   1          // TH0 = (65536-50000)/256;   // è®¾ç½®å®šæ—¶å™¨0çš„åˆå§‹å€¼ï¼Œå®šæ—¶50ms
 135   1          // TL0 = (65536-50000)%256; 
 136   1      
 137   1          // æ¯éš”1æ¯«ç§’ä¸­æ–­ä¸€æ¬¡
 138   1          TL0 = 0x66;                                  
 139   1              TH0 = 0xFC;            
 140   1      
 141   1              if(++ KeyStartTime == 10)//æ¯éš”10msæ»¡è¶³æ¡ä»¶ï¼Œæ‰«ææŒ‰é”®
 142   1              {
 143   2                      KeyStartTime = 0;
 144   2                      Key_Scan();
 145   2              }
 146   1      }
 147          
 148          void Key_Scan(void)
 149          {
 150   1              switch(keyState)
 151   1              {
 152   2                      case Key_Check://å¹³å¸¸çŠ¶æ€
 153   2                      {
 154   3                              if(Key == 0)
 155   3                              {
 156   4                                      keyState = Key_Press;//åœ¨æ£€æµ‹çŠ¶æ€ä¸‹ï¼Œæ£€æµ‹æ˜¯å¦æœ‰æŒ‰é”®æŒ‰ä¸‹ï¼Œå¦‚æžœæœ‰ï¼Œè½¬æ¢ä¸ºæŒ‰ä¸‹ç
             -Š¶æ€
 157   4                              }
 158   3                      };
 159   2                      break;
 160   2                      case Key_Press://åœ¨æŒ‰ä¸‹çŠ¶æ€ä¸‹ï¼Œåˆ¤æ–­å…·ä½“æ˜¯å“ªä¸ªæŒ‰é”®æŒ‰ä¸‹ï¼Œç»™äºˆé”®å€¼
 161   2                      {
 162   3                              keyPressCount ++;
 163   3                  keyPressCount %= 4;
 164   3      
 165   3                              keyState = Key_Release;//ä¸ç®¡æ¾æ²¡æ¾æ‰‹ï¼Œç›´æŽ¥è¿›å…¥â€œæ¾æ‰‹â€çŠ¶æ€
 166   3                      };
 167   2                      break;
 168   2                      case Key_Release://åœ¨â€œæ¾æ‰‹â€çŠ¶æ€ä¸‹ï¼Œåˆ¤æ–­æ˜¯å¦çœŸçš„æ¾æ‰‹
 169   2                      {
 170   3                              if(Key == 0)
 171   3                              {
 172   4                                      keyPressTime += 10;//è¿‡äº†10msï¼Œå‘çŽ°è¿˜æ²¡æ¾æ‰‹ï¼ŒæŒ‰åŽ‹æ—¶é—´+10
 173   4                              }
 174   3                              else//çœŸçš„æ¾æ‰‹äº†ï¼Œåˆ¤æ–­ä¸ºçŸ­æŒ‰
 175   3                              {
 176   4                                      keyState = Key_Over;//æ­¤æ—¶ä¸ºæŒ‰ä¸‹åŽæ¾æ‰‹çš„çŠ¶æ€
C51 COMPILER V9.59.0.0   MAIN                                                              01/08/2025 21:30:01 PAGE 4   

 177   4                              }
 178   3                      };
 179   2                      break;
 180   2                      default:break;
 181   2              }
 182   1      }
 183          
 184          void Timer0Init()     // å®šæ—¶å™¨0å‡½æ•°  ä»¥ä¸»é¢‘12M
 185          {
 186   1          
 187   1          TMOD&=0xF0;                        //TMODæ¸…0
 188   1          TMOD|=0x01;                       // è®¾ç½®å®šæ—¶å™¨0ä¸ºå·¥ä½œæ–¹å¼1ï¼ˆ16ä½å®šæ—¶å™¨ï¼‰
 189   1          TH0=(65536-50000)/256;           // è®¾ç½®å®šæ—¶å™¨0çš„åˆå§‹å€¼ï¼Œå®šæ—¶50ms
 190   1          TL0=(65536-50000)%256;      
 191   1          TR0=1;                          // å¼€å¯å®šæ—¶å™¨0    
 192   1          ET0=1;                         // å…è®¸å®šæ—¶å™¨0ä¸­æ–­   
 193   1          EA=1;                         // å¼€å¯æ€»ä¸­æ–­
 194   1      
 195   1      }
 196          
 197          void delay(uchar z)       //æŒ‰é”®å»¶æ—¶æ¶ˆæŠ–
 198          {
 199   1              uchar x,y;
 200   1              for(x=z;x>0;x--)
 201   1                      for(y=110;y>0;y--);
 202   1      }
 203          
 204          
 205          
 206          
 207          
 208          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    263    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
