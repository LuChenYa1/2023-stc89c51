C51 COMPILER V9.59.0.0   MATRIXLED                                                         12/09/2023 12:34:51 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MATRIXLED
OBJECT MODULE PLACED IN .\Objects\MatrixLED.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE MatrixLED.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\MatrixLED.lst) OBJECT(.\Objects\MatrixLED.obj)

line level    source

   1          #include <REGX51.H>
   2          #include "delay.h"
   3          #define MatrixLED_lie P0       //提高可读性，方便后期替换操作寄存器
   4          
   5          #define uint8_t unsigned char 
   6          
   7          //对位进行重命名，不能用_,要用^
   8          sbit SCK = P2^2;               //串行数据，一次赋值一位
   9          sbit SER = P2^3;               //寄存器时钟，存满8位后触发RCK=1，将八位数据并行输入到DH~DA（D7到D1）
  10          sbit RCK = P2^4;               //串行时钟，每输入一位就触发该时钟将数据上移，一直移到最高位DH
  11          
  12          
  13          /**
  14            * @brief    初始化寄存器时钟和串行时钟
  15            * @param    无
  16            * @retval   无
  17            */
  18          void MatrixLED_Init(void)
  19          {
  20   1              SCK=0;        //SCK需要手动复位和开启
  21   1              RCK=0;        //RCK需要手动复位和开启
  22   1      }
  23                  
  24                  
  25          /**
  26            * @brief  两个595级联，一次性传输两字节数据
  27            * @brief  顺序将byte从高到低的数值赋值给SER,再传递给D7到D0,D15~D8
  28            * @param  一次只有一行亮，列高行低，列为十进制（易读）
  29            * @retval 无
  30            */
  31          void MatrixLED_8_ShowColumn(unsigned char Lie, unsigned char  HangData)
  32          {
  33   1              unsigned char i;
  34   1              
  35   1              for(i=0;i<8;i++)
  36   1              {
  37   2                      SER = !(HangData & (0x80>>i));  
  38   2                      SCK = 1;  //上移一位
  39   2                      SCK = 0;  //复位
  40   2              }
  41   1              for(i=0;i<8;i++)
  42   1              {
  43   2                      SER = (0x01 << (Lie-1)) & (0x80>>i);  
  44   2                      SCK = 1;  //上移一位
  45   2                      SCK = 0;  //复位
  46   2              }
  47   1              RCK = 1;      //并行输入8位
  48   1              RCK = 0;      //复位
  49   1              //不用自己清零SER，会有问题，直接再次赋值就可以
  50   1              //      Delay_ms(1);
  51   1      }
  52          
  53          
  54          /**
C51 COMPILER V9.59.0.0   MATRIXLED                                                         12/09/2023 12:34:51 PAGE 2   

  55            * @brief  四个595级联，一次性传输四字节数据
  56            * @brief  顺序将byte从高到低的数值赋值给SER
  57            * @param  一次只有一行亮，列高行低，列为十进制（易读）
  58            * @retval 无
  59            */
  60          void MatrixLED_16_ShowColumn(unsigned char Lie, unsigned char H_HangData, unsigned char L_HangData)
  61          {
  62   1              unsigned char i;
  63   1              
  64   1              for(i=0;i<8;i++)//第4组数据，行的高八位
  65   1              {
  66   2                      SER = !(H_HangData & (0x80>>i));  
  67   2                      SCK = 1;  //上移一位
  68   2                      SCK = 0;  //复位
  69   2              }
  70   1              for(i=0;i<8;i++)//第3组数据，行的低八位
  71   1              {
  72   2                      SER = !(L_HangData & (0x80>>i));  
  73   2                      SCK = 1;  //上移一位
  74   2                      SCK = 0;  //复位
  75   2              }
  76   1              for(i=0;i<8;i++)//第2组数据，列的高八位
  77   1              {
  78   2                      if(Lie > 8 && Lie < 16)SER = (0x01 << ((Lie % 8)-1)) & (0x80>>i);  
  79   2                      else if(Lie == 16)SER = (0x01 << (8-1)) & (0x80>>i);
  80   2                      else SER = (0x00) & (0x80>>i);  
  81   2                      SCK = 1;  //上移一位
  82   2                      SCK = 0;  //复位
  83   2              }
  84   1              for(i=0;i<8;i++)//第1组数据，列的低八位
  85   1              {
  86   2                      if(Lie < 8)SER = (0x01 << ((Lie % 8)-1)) & (0x80>>i); 
  87   2                      else if(Lie == 8)SER = (0x01 << (8-1)) & (0x80>>i); 
  88   2                      else SER = (0x00) & (0x80>>i);
  89   2                      SCK = 1;  //上移一位
  90   2                      SCK = 0;  //复位
  91   2              }
  92   1              RCK = 1;      //并行输入8位
  93   1              RCK = 0;      //复位
  94   1              //不用自己清零SER，会有问题，直接再次赋值就可以
  95   1              //Delay_ms(1);
  96   1      }
  97          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    474    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
