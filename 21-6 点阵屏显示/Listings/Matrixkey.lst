C51 COMPILER V9.59.0.0   MATRIXKEY                                                         12/07/2023 20:48:54 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MATRIXKEY
OBJECT MODULE PLACED IN .\Objects\Matrixkey.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE Matrixkey.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\Matrixkey.lst) OBJECT(.\Objects\Matrixkey.obj)

line level    source

   1          #include <REGX51.H>
   2          #include <delay.h>
   3           
   4           //定时器扫描矩阵键盘
   5           unsigned char Scan_MatrixKeyNum;
   6           /**
   7            * @brief  矩阵键盘读取按键键码
   8            * @param  无
   9            * @retval 键码KeyNum
  10                  按下并松开后重新赋值并显示
  11            */  
  12          unsigned char Matrixkey_GetState()
  13           {
  14   1               //列扫描
  15   1               unsigned char MatrixKeyNum = 0;//这一步赋值0很重要，不能省略
  16   1               P1=0xff;     //全部复位
  17   1               P1_0=0;      //确定扫描列数          
  18   1               if(P1_4==0){MatrixKeyNum=16;}
  19   1               if(P1_5==0){MatrixKeyNum=12;}
  20   1               if(P1_6==0){MatrixKeyNum=8;}
  21   1               if(P1_7==0){MatrixKeyNum=4;}
  22   1               
  23   1               
  24   1               P1=0xff;
  25   1               P1_1=0;
  26   1               if(P1_4==0){MatrixKeyNum=15;}
  27   1               if(P1_5==0){MatrixKeyNum=11;}
  28   1               if(P1_6==0){MatrixKeyNum=7;}
  29   1               if(P1_7==0){MatrixKeyNum=3;}
  30   1               
  31   1               P1=0xff;
  32   1               P1_2=0;
  33   1               if(P1_4==0){MatrixKeyNum=14;}
  34   1               if(P1_5==0){MatrixKeyNum=10;}
  35   1               if(P1_6==0){MatrixKeyNum=6;}
  36   1               if(P1_7==0){MatrixKeyNum=2;}
  37   1               
  38   1               P1=0xff;
  39   1               P1_3=0;
  40   1               if(P1_4==0){MatrixKeyNum=13;}
  41   1               if(P1_5==0){MatrixKeyNum=9;}
  42   1               if(P1_6==0){MatrixKeyNum=5;}
  43   1               if(P1_7==0){MatrixKeyNum=1;}
  44   1                
  45   1               return MatrixKeyNum;
  46   1       }
  47          /**
  48            * @brief  中断时执行的函数，功能是检测按键落下并返回相应的值，去除了原来的delay和死循环
  49            * @param  无
  50            * @retval 无
  51            */
  52          void MatrixKey_Loop(void)
  53          {
  54   1              static unsigned char laststate,nowstate;
C51 COMPILER V9.59.0.0   MATRIXKEY                                                         12/07/2023 20:48:54 PAGE 2   

  55   1              laststate = nowstate;
  56   1              nowstate = Matrixkey_GetState();
  57   1              //更换10位置可以按下即变，不需松手
  58   1              if(laststate==1&&nowstate==0)Scan_MatrixKeyNum = 1;     
  59   1              else if(laststate==2 && nowstate == 0)Scan_MatrixKeyNum = 2;    
  60   1              else if(laststate==3 && nowstate == 0)Scan_MatrixKeyNum = 3;    
  61   1              else if(laststate==4 && nowstate == 0)Scan_MatrixKeyNum = 4;    
  62   1              else if(laststate==5 && nowstate == 0)Scan_MatrixKeyNum = 5;    
  63   1              else if(laststate==6 && nowstate == 0)Scan_MatrixKeyNum = 6;    
  64   1              else if(laststate==7 && nowstate == 0)Scan_MatrixKeyNum = 7;    
  65   1              else if(laststate==8 && nowstate == 0)Scan_MatrixKeyNum = 8;    
  66   1              else if(laststate==9 && nowstate == 0)Scan_MatrixKeyNum = 9;    
  67   1              else if(laststate==10&& nowstate == 0)Scan_MatrixKeyNum = 10;   
  68   1              else if(laststate==11&& nowstate == 0)Scan_MatrixKeyNum = 11;   
  69   1              else if(laststate==12&& nowstate == 0)Scan_MatrixKeyNum = 12;   
  70   1              else if(laststate==13&& nowstate == 0)Scan_MatrixKeyNum = 13;   
  71   1              else if(laststate==14&& nowstate == 0)Scan_MatrixKeyNum = 14;   
  72   1              else if(laststate==15&& nowstate == 0)Scan_MatrixKeyNum = 15;   
  73   1              else if(laststate==16&& nowstate == 0)Scan_MatrixKeyNum = 16;   
  74   1      }
  75          /**
  76            * @brief  返回按键键码
  77            * @param  无
  78            * @retval 键码
  79            */
  80          unsigned char MatrixKey(void)
  81          {
  82   1              unsigned char temp;
  83   1              temp = Scan_MatrixKeyNum;     //返回按键值前对Scan_KeyNum清零,防止不按下时返回原值
  84   1              Scan_MatrixKeyNum = 0;
  85   1              return temp;
  86   1      }
  87          
  88          
  89          //#include <REGX51.H>
  90          //#include <delay.h>
  91          // 
  92          // /**
  93          //  * @brief  矩阵键盘读取按键键码
  94          //  * @param  参数无
  95          //  * @retval 返回值为键码
  96          //      按下并松开后重新赋值并显示
  97          //  */  
  98          //unsigned char MatrixKey()
  99          // {
 100          //       //列扫描
 101          //       unsigned char KeyNum = 0;
 102          //       P1=0xff;
 103          //       P1_0=0;      //确定扫描列数          
 104          //       if(P1_4==0){delay_ms(20);while(P1_4==0);delay_ms(20);KeyNum=16;}
 105          //       if(P1_5==0){delay_ms(20);while(P1_5==0);delay_ms(20);KeyNum=12;}
 106          //       if(P1_6==0){delay_ms(20);while(P1_6==0);delay_ms(20);KeyNum=8;}
 107          //       if(P1_7==0){delay_ms(20);while(P1_7==0);delay_ms(20);KeyNum=4;}
 108          //       
 109          //       
 110          //       P1=0xff;
 111          //       P1_1=0;
 112          //       if(P1_4==0){delay_ms(20);while(P1_4==0);delay_ms(20);KeyNum=15;}
 113          //       if(P1_5==0){delay_ms(20);while(P1_5==0);delay_ms(20);KeyNum=11;}
 114          //       if(P1_6==0){delay_ms(20);while(P1_6==0);delay_ms(20);KeyNum=7;}
 115          //       if(P1_7==0){delay_ms(20);while(P1_7==0);delay_ms(20);KeyNum=3;}
 116          //       
C51 COMPILER V9.59.0.0   MATRIXKEY                                                         12/07/2023 20:48:54 PAGE 3   

 117          //       P1=0xff;
 118          //       P1_2=0;
 119          //       if(P1_4==0){delay_ms(20);while(P1_4==0);delay_ms(20);KeyNum=14;}
 120          //       if(P1_5==0){delay_ms(20);while(P1_5==0);delay_ms(20);KeyNum=10;}
 121          //       if(P1_6==0){delay_ms(20);while(P1_6==0);delay_ms(20);KeyNum=6;}
 122          //       if(P1_7==0){delay_ms(20);while(P1_7==0);delay_ms(20);KeyNum=2;}
 123          //       
 124          //       P1=0xff;
 125          //       P1_3=0;
 126          //       if(P1_4==0){delay_ms(20);while(P1_4==0);delay_ms(20);KeyNum=13;}
 127          //       if(P1_5==0){delay_ms(20);while(P1_5==0);delay_ms(20);KeyNum=9;}
 128          //       if(P1_6==0){delay_ms(20);while(P1_6==0);delay_ms(20);KeyNum=5;}
 129          //       if(P1_7==0){delay_ms(20);while(P1_7==0);delay_ms(20);KeyNum=1;}
 130          //       
 131          //       
 132          //       return KeyNum;
 133          // }
 134          
 135          // unsigned char MatrixKey()
 136          // {
 137          //       //列扫描
 138          //       unsigned char KeyNum, temp1, temp2;
 139          //       P1=0xf0;
 140          //       ...
 141          //       temp1 = P1;
 142          //       P1 = 0x0f;
 143          //       ...
 144          //       temp2 = P1;
 145          //       keyNum = temp1 | temp2;
 146          //       
 147          //       
 148          //       return KeyNum;
 149          // }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    356    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
