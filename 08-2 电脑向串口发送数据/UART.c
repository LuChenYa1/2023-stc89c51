#include <REGX51.H>

typedef  unsigned char uchar;


/*************************************************************************
函数名称:UART_Init
函数功能:设置串口接收模式，也能发送

**************************************************************************/
void UART_Init(void)      //4800bps@11.0592MHz
{
	                      //0x50比0x40多了REN=1,允许接收数据
	SCON = 0x50;          //串口模式1（常用），八位数据，可变波特率，和定时器模式2（八位自动重装）不是一个东西
	PCON |=0x80;          //最高位置一，其他位不变，波特率加倍（本来是为了减小误差，但这里已经无误差，可不加倍）
	//	AUXR &= 0xBF;	  //高级功能，该型号单片机没有	
	//	AUXR &= 0xFE;	  //调12T和定时器1
	TMOD &=0x0F;          //高四位清零，低四位不变，调定时器1
    TMOD |=0x20;          //调定时器1的模式二，八位自动重装模式
	TL1=0xF4;             //设置定时初值
	TH1=0xF4;             //设定定时器重装值
	ET1=0;                //禁止定时器1中断，只提供定时功能，中断没有用
	TR1=1;                //启动定时器
	//独属于需要接受数据的时候的配置
   	EA=1;                 //开启中断总开关
	ES=1;                 //开启串口中断
}
//定时器1中断的触发条件是时间到了，定时结束，定时器1用来配置波特率，没有必要开启中断
//串口中断的触发条件是接收数据或者发送数据



/*************************************************************************
函数名称:UART_SendByte
函数功能:发送一个字符

**************************************************************************/
void UART_SendByte(uchar byte)
{
	SBUF=byte;                    //SBUF有两个，一个是发送区，一个是接受区，空间不一样，但占用同一个地址
	while(TI==0);
	TI=0;                         //一旦发送，立即软件复位
}


/*************************************************************************
函数名称:UART_SendString
函数功能:发送一个字符串

**************************************************************************/
void UART_SendString(uchar *String)
{
    while(*String)
    {
        UART_SendByte(*String);
        String++;
    }
}


/*********************************************************************************** 
函数名称:UART_SendIntNumber
函数功能:串口发送整形数字

**************************************************************************/
void UART_SendIntNumber(int Number)
{
    unsigned char NumbArray[6]={0};    // // 定义局部数组，用于数据存储
    if(Number<0)
    {
        Number = 0-Number;
        UART_SendByte('-');
    }
    else
    {
       UART_SendByte('+');
    }
    
    NumbArray[0]=(Number/10000)%10+0x30; 
    NumbArray[1]=(Number/1000) %10+0x30;
    NumbArray[2]=(Number/100)  %10+0x30;
    NumbArray[3]=(Number/10)   %10+0x30;
    NumbArray[4]=(Number/1)    %10+0x30; 
    NumbArray[5]= 0;     
    UART_SendString(NumbArray);
}


/*********************************************************************************** 
函数名称:UART_SendFloatNumber
函数功能:串口发送浮点型数字
***********************************************************************************/

void UART_SendFloatNumber(float Number)
{
    unsigned char NumberArray[11]={0};              // 定义局部数组，用于数据存储
    unsigned char i=1;                              // 定义局部变量，记录整数位数
    long j=1;
    unsigned int Real_Int=0;                        // 定义局部变量，记录整数部分
    unsigned int Real_Dec=0;                        // 定义局部变量，记录小数部分

    double Deci=0;                                  // 定义局部数组，暂存小数数组
    
    //----------------------------------------------------------------------------------------------
    // 判断，浮点数字正负
    //----------------------------------------------------------------------------------------------
    if(Number<0)
    {
        Number=0-Number;
        UART_SendByte('-');
    }
    else
    {
        UART_SendByte('+');
    }

    //----------------------------------------------------------------------------------------------
    // 分离，整数位与小数位
    //----------------------------------------------------------------------------------------------
    Real_Int=(int)Number;                           // 取整数部分
    Deci    =Number-Real_Int;                       // 取小数部分
    Real_Dec=(unsigned int)(Deci*1e4);              // 小数变整形数字


    //----------------------------------------------------------------------------------------------
    // 串口输出
    //----------------------------------------------------------------------------------------------
    NumberArray[0] = (Real_Int/10000)%10+0x30;
    NumberArray[1] = (Real_Int/1000) %10+0x30;
    NumberArray[2] = (Real_Int/100)  %10+0x30;
    NumberArray[3] = (Real_Int/10)   %10+0x30;
    NumberArray[4] = (Real_Int/1)    %10+0x30;
    NumberArray[5] = '.';
    NumberArray[6] = (Real_Dec/1000)%10+0x30;
    NumberArray[7] = (Real_Dec/100) %10+0x30;
    NumberArray[8] = (Real_Dec/10)  %10+0x30;
    NumberArray[9] = (Real_Dec/1)   %10+0x30;
    NumberArray[10]= 0;

    UART_SendString(NumberArray);
}


 /**
  * @brief  串口中断函数模板
  * @param  无
  * @retval 无
  */
//void UART_Routine()   interrupt 4 //串口中断对应中断号
//{
//	if(RI==1)                     //发送和接收中断占用的是一个通道，都会触发中断函数，加if判断防止误触
//	{
//		RI=0;                     //（手动）软件复位
//	}
//}

